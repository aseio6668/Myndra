<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pomegranate3D - Intermediate Tutorial</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #8B5CF6 0%, #EC4899 25%, #F59E0B 50%, #10B981 75%, #06B6D4 100%);
            color: #333;
        }
        .container {
            max-width: 1300px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        h1 {
            color: #4a5568;
            border-bottom: 3px solid #8B5CF6;
            padding-bottom: 10px;
            text-align: center;
            background: linear-gradient(135deg, #8B5CF6, #EC4899, #F59E0B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        h2 {
            color: #2d3748;
            margin-top: 30px;
            border-left: 4px solid #EC4899;
            padding-left: 15px;
        }
        h3 {
            color: #4a5568;
        }
        .code-block {
            background: #0f172a;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            border-left: 4px solid #EC4899;
            position: relative;
            font-size: 14px;
        }
        .code-block::before {
            content: "Pomegranate3D";
            position: absolute;
            top: 5px;
            right: 10px;
            background: linear-gradient(135deg, #8B5CF6, #EC4899);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .shader-block {
            background: #1e1b4b;
            color: #a5b4fc;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            border-left: 4px solid #6366f1;
            position: relative;
        }
        .shader-block::before {
            content: "🎨 Shader";
            position: absolute;
            top: 5px;
            right: 10px;
            background: #6366f1;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .highlight {
            background: #fef3c7;
            padding: 15px;
            border-left: 4px solid #f59e0b;
            border-radius: 4px;
            margin: 15px 0;
        }
        .feature-box {
            background: #dbeafe;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3b82f6;
        }
        .magic-box {
            background: #f3e8ff;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #8b5cf6;
        }
        .advanced-box {
            background: #fef2f2;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #ef4444;
        }
        .physics-box {
            background: #ecfdf5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #10b981;
        }
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
        }
        .nav-button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #8B5CF6, #EC4899);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: transform 0.3s;
        }
        .nav-button:hover {
            transform: scale(1.05);
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 8px 0;
        }
        .demo-viewport {
            background: #1a202c;
            border: 2px solid #EC4899;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            color: #e2e8f0;
        }
        .shader-explanation {
            background: #1e293b;
            color: #cbd5e1;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 3px solid #6366f1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔥 Pomegranate3D - Intermediate Tutorial</h1>
        
        <div class="highlight">
            <strong>Level Up Your 3D Skills!</strong> This tutorial covers advanced materials, custom shaders, physics integration, lighting techniques, and performance optimization. You'll learn to create stunning visual effects that would take weeks in traditional 3D programming.
        </div>

        <h2>1. Advanced Material Systems</h2>
        <p>Move beyond basic colors to create photorealistic materials:</p>

        <h3>Physically-Based Rendering (PBR)</h3>
        <div class="code-block">
<pre>fn create_realistic_materials() {
    // Metal materials
    let gold_sphere = mesh::sphere {
        radius: 1.0
        position: vec3(-4, 0, 0)
        material: materials::pbr {
            albedo: color(1.0, 0.766, 0.336)    // Gold color
            metallic: 1.0                       // Fully metallic
            roughness: 0.1                      // Very smooth, mirror-like
            emissive: color(0.0, 0.0, 0.0)      // No glow
            
            // Advanced PBR properties
            specular: 0.9                       // How reflective
            clearcoat: 0.0                      // Car paint effect
            sheen: 0.0                          // Fabric-like reflection
        }
    }
    
    // Rough stone material
    let stone_cube = mesh::cube {
        size: vec3(2, 2, 2)
        position: vec3(0, 0, 0)
        material: materials::pbr {
            albedo: color(0.4, 0.4, 0.45)
            metallic: 0.0                       // Not metallic
            roughness: 0.9                      // Very rough surface
            normal_strength: 1.5                // Pronounced surface bumps
            
            // Texture maps for realism
            albedo_texture: "stone_color.jpg"
            normal_texture: "stone_normal.jpg"
            roughness_texture: "stone_roughness.jpg"
            height_texture: "stone_height.jpg"
            
            // Texture tiling
            texture_scale: vec2(2.0, 2.0)      // Repeat texture 2x
        }
    }
    
    // Glass with subsurface scattering
    let glass_torus = mesh::torus {
        major_radius: 1.5
        minor_radius: 0.5
        position: vec3(4, 0, 0)
        material: materials::glass {
            base_color: color(0.95, 0.98, 1.0, 0.1)  // Almost clear with blue tint
            transmission: 0.98                         // Almost fully transparent
            ior: 1.52                                 // Glass refractive index
            roughness: 0.0                            // Perfect glass
            thickness: 0.5                            // For subsurface effects
            
            // Caustics and light scattering
            enable_caustics: true
            subsurface_scattering: 0.1
        }
    }
}</pre>
        </div>

        <h3>Animated and Dynamic Materials</h3>
        <div class="code-block">
<pre>fn create_animated_materials() {
    let pulsing_crystal = mesh::icosphere {
        radius: 1.2
        subdivisions: 4
        position: vec3(0, 2, 0)
        material: materials::pbr {
            // Base color shifts over time
            albedo: color(
                0.5 + sin(time * 2.0) * 0.3,      // Red channel oscillates
                0.3 + cos(time * 1.5) * 0.2,      // Green channel oscillates
                0.8 + sin(time * 3.0) * 0.1       // Blue channel oscillates
            )
            
            // Metallic property changes
            metallic: (sin(time) + 1.0) * 0.5     // 0.0 to 1.0 over time
            
            // Pulsing emission
            emissive: color(
                sin(time * 4.0) * 0.5 + 0.5,      // Pulsing red
                cos(time * 3.0) * 0.3 + 0.3,      // Pulsing green  
                sin(time * 5.0) * 0.2 + 0.6       // Pulsing blue
            )
            
            roughness: 0.1
        }
    }
    
    // Material that reacts to camera distance
    let reactive_cube = mesh::cube {
        size: vec3(1, 1, 1)
        position: vec3(3, 0, 3)
        material: materials::pbr {
            albedo: color(0.7, 0.2, 0.9)
            metallic: 0.0
            roughness: 0.5
        }
    }
    
    // Reactive material behavior
    @reactive
    fn update_reactive_material() {
        let camera_distance = (camera.position - reactive_cube.position).magnitude()
        let proximity = clamp(1.0 - (camera_distance / 10.0), 0.0, 1.0)
        
        // Glow increases as camera gets closer
        reactive_cube.material.emissive -> color(proximity, proximity * 0.5, proximity * 0.8) over 200ms
        
        // Scale slightly increases when close
        reactive_cube.scale -> vec3(1.0 + proximity * 0.2) over 300ms
    }
}</pre>
        </div>

        <h2>2. Custom Shaders - The Heart of Visual Effects</h2>
        <p>Write custom shaders directly in Pomegranate3D - no separate files or string concatenation:</p>

        <h3>Vertex Shaders - Controlling Geometry</h3>
        <div class="shader-block">
<pre>// Wavy water surface shader
shader ocean_waves {
    vertex {
        // Get the original vertex position
        let world_pos = vertex.position
        
        // Create multiple wave patterns
        let wave1 = sin(world_pos.x * 0.1 + time * 2.0) * 0.8
        let wave2 = cos(world_pos.z * 0.15 + time * 1.5) * 0.6
        let wave3 = sin((world_pos.x + world_pos.z) * 0.08 + time * 0.8) * 0.4
        
        // Combine waves for complex motion
        vertex.position.y += wave1 + wave2 + wave3
        
        // Calculate new normal for proper lighting
        let dx = cos(world_pos.x * 0.1 + time * 2.0) * 0.08
        let dz = -sin(world_pos.z * 0.15 + time * 1.5) * 0.09
        vertex.normal = normalize(vec3(-dx, 1.0, -dz))
        
        // Pass wave height to fragment shader
        vertex.custom_data.wave_height = wave1 + wave2 + wave3
    }
    
    fragment {
        // Water color based on wave height
        let base_color = color(0.1, 0.3, 0.6)
        let foam_color = color(0.8, 0.9, 1.0)
        
        // Add foam at wave peaks
        let foam_factor = clamp(fragment.custom_data.wave_height * 2.0, 0.0, 1.0)
        let final_color = mix(base_color, foam_color, foam_factor)
        
        // Add some transparency
        fragment.color = color(final_color.rgb, 0.7)
    }
}</pre>
        </div>

        <div class="shader-explanation">
            <strong>🎨 What this shader does:</strong> Creates realistic ocean waves with multiple sine wave patterns. The vertex shader moves geometry to create wave motion, while the fragment shader adds foam effects at wave peaks.
        </div>

        <h3>Fragment Shaders - Advanced Visual Effects</h3>
        <div class="shader-block">
<pre>// Hologram effect shader
shader hologram_effect {
    fragment {
        let world_pos = fragment.world_position
        let view_dir = normalize(camera.position - world_pos)
        
        // Scanlines effect
        let scanline = sin(world_pos.y * 50.0 + time * 10.0)
        let scanline_intensity = smoothstep(0.3, 0.7, scanline)
        
        // Fresnel effect for edge glow
        let fresnel = 1.0 - dot(fragment.normal, view_dir)
        fresnel = pow(fresnel, 2.0)
        
        // Noise for glitch effect
        let noise = random(world_pos.xy + time * 0.1)
        let glitch = step(0.95, noise)
        
        // Base hologram color
        let base_color = color(0.2, 0.8, 1.0)
        
        // Combine effects
        let final_color = base_color * (0.5 + scanline_intensity * 0.5)
        final_color += base_color * fresnel * 2.0          // Edge glow
        final_color += color(1.0, 1.0, 1.0) * glitch * 0.8 // Glitch flashes
        
        // Make transparent with varying alpha
        let alpha = 0.3 + fresnel * 0.4 + scanline_intensity * 0.2
        fragment.color = color(final_color.rgb, alpha)
    }
}</pre>
        </div>

        <h3>Animated Noise Shader</h3>
        <div class="shader-block">
<pre>// Animated plasma/energy field
shader energy_field {
    fragment {
        let uv = fragment.texture_coordinates
        let world_pos = fragment.world_position
        
        // Multiple layers of noise
        let noise1 = noise(uv * 3.0 + time * 0.5)
        let noise2 = noise(uv * 6.0 + time * 0.8)
        let noise3 = noise(uv * 12.0 + time * 1.2)
        
        // Combine noise layers
        let combined_noise = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2
        
        // Create color bands
        let bands = sin(combined_noise * 8.0 + time * 2.0) * 0.5 + 0.5
        
        // Color gradient based on noise
        let color1 = color(1.0, 0.2, 0.8)  // Hot pink
        let color2 = color(0.2, 0.8, 1.0)  // Cyan
        let color3 = color(1.0, 0.8, 0.2)  // Yellow
        
        let final_color = mix(
            mix(color1, color2, bands),
            color3,
            combined_noise
        )
        
        // Pulsing brightness
        let pulse = sin(time * 3.0) * 0.3 + 0.7
        fragment.color = final_color * pulse
        
        // Add emission for glow
        fragment.emission = final_color * 0.5
    }
}</pre>
        </div>

        <h2>3. Advanced Lighting Techniques</h2>
        <p>Master complex lighting setups for cinematic results:</p>

        <div class="code-block">
<pre>fn create_cinematic_lighting() {
    lighting {
        // Three-point lighting setup (professional film lighting)
        
        // Key light (main light source)
        light::directional {
            name: "key_light"
            direction: vec3(-0.5, -1.0, -0.2).normalized()
            color: color(1.0, 0.95, 0.8)       // Warm white
            intensity: 2.5
            cast_shadows: true
            shadow_quality: high
            shadow_distance: 50.0
        }
        
        // Fill light (softens shadows)
        light::directional {
            name: "fill_light"
            direction: vec3(0.8, -0.3, 0.5).normalized()
            color: color(0.7, 0.8, 1.0)        // Cool blue tint
            intensity: 0.8
            cast_shadows: false                  // No competing shadows
        }
        
        // Back light (rim lighting for separation)
        light::directional {
            name: "back_light"
            direction: vec3(0.2, -0.1, 1.0).normalized()
            color: color(1.0, 0.9, 0.7)
            intensity: 1.2
            cast_shadows: false
        }
        
        // Ambient lighting with color variation
        ambient: {
            // Different ambient colors based on world height
            ground_color: color(0.3, 0.25, 0.2)    // Warm ground reflection
            sky_color: color(0.2, 0.25, 0.4)       // Cool sky color
            horizon_color: color(0.4, 0.35, 0.3)   // Warm horizon
        }
        
        // Volumetric fog for atmosphere
        fog: {
            color: color(0.7, 0.8, 0.9)
            density: 0.02
            start_distance: 10.0
            end_distance: 100.0
            
            // Animated fog movement
            wind_direction: vec3(1.0, 0.0, 0.3)
            wind_speed: 0.5
        }
    }
    
    // Dynamic lighting that changes over time
    create_dynamic_lighting()
}

fn create_dynamic_lighting() {
    // Flickering torch effect
    let torch_light = light::point {
        position: vec3(2, 3, 0)
        color: color(1.0, 0.6, 0.2)            // Orange flame color
        range: 8.0
        cast_shadows: true
        
        // Flickering animation
        intensity: 3.0 + sin(time * 8.0) * 0.5 + cos(time * 12.0) * 0.3
    }
    
    // Moving spotlight (like a searchlight)
    let search_light = light::spot {
        position: vec3(0, 8, 0)
        color: color(0.9, 0.9, 1.0)
        intensity: 5.0
        inner_angle: 15.degrees
        outer_angle: 25.degrees
        range: 20.0
        cast_shadows: true
        
        // Rotating direction
        direction: vec3(
            sin(time * 0.5),
            -1.0,
            cos(time * 0.5)
        ).normalized()
    }
    
    // Lightning effect (occasional flashes)
    if random() > 0.995 {  // Rare random event
        light::point {
            position: vec3(
                random_range(-10, 10),
                15,
                random_range(-10, 10)
            )
            color: color(0.9, 0.95, 1.0)
            intensity: 50.0                     // Very bright flash
            range: 25.0
            lifetime: 0.1s                      // Brief flash
        }
    }
}</pre>
        </div>

        <h2>4. Physics Integration</h2>
        <p>Add realistic physics to your 3D scenes:</p>

        <div class="physics-box">
            <h3>🎯 Physics-Driven Animation</h3>
            <div class="code-block">
<pre>import physics3d with capabilities("simulate", "collide")

fn create_physics_playground() {
    // Physics world configuration
    physics_world {
        gravity: vec3(0, -9.81, 0)
        air_resistance: 0.01
        
        // Global physics settings
        solver_iterations: 8            // Higher = more accurate
        collision_margin: 0.04          // Collision detection threshold
        enable_ccd: true               // Continuous collision detection
    }
    
    // Static ground plane
    let ground = mesh::plane {
        size: vec2(20, 20)
        position: vec3(0, -1, 0)
        material: materials::pbr {
            albedo: color(0.5, 0.5, 0.5)
            roughness: 0.8
        }
        physics: {
            type: static                // Never moves
            collision_shape: plane
            friction: 0.7               // Surface friction
            restitution: 0.3           // Bounciness
        }
    }
    
    // Dynamic falling cubes
    for i in 0..10 {
        let cube = mesh::cube {
            size: vec3(1, 1, 1)
            position: vec3(
                random_range(-3.0, 3.0),
                5.0 + i * 2.0,
                random_range(-3.0, 3.0)
            )
            material: materials::pbr {
                albedo: color(random(), random(), random())
                metallic: random() * 0.5
                roughness: 0.2 + random() * 0.6
            }
            physics: {
                type: dynamic           // Affected by gravity and forces
                mass: 1.0
                collision_shape: box
                friction: 0.5
                restitution: 0.4        // Bouncy
            }
        }
    }
    
    // Kinematic moving platform
    let platform = mesh::cube {
        size: vec3(4, 0.5, 4)
        position: vec3(5, 2, 0)
        material: color(0.2, 0.8, 0.2)
        physics: {
            type: kinematic         // Controlled by animation, affects others
            collision_shape: box
        }
    }
    
    // Animate platform movement
    platform.position.y -> 4.0 over 3s 
        then platform.position.y -> 2.0 over 3s 
        then loop
    
    // Bowling ball launcher
    @user_input("space")
    fn launch_bowling_ball() {
        let ball = mesh::sphere {
            radius: 0.8
            position: camera.position + camera.forward * 2.0
            material: materials::pbr {
                albedo: color(0.1, 0.1, 0.1)
                metallic: 0.8
                roughness: 0.1
            }
            physics: {
                type: dynamic
                mass: 5.0               // Heavy ball
                collision_shape: sphere
                friction: 0.8
                restitution: 0.2
                
                // Initial velocity toward camera direction
                initial_velocity: camera.forward * 15.0
            }
        }
    }
}</pre>
            </div>
        </div>

        <h3>Advanced Physics Features</h3>
        <div class="code-block">
<pre>fn create_physics_contraptions() {
    // Chain/rope simulation
    let chain_links = []
    let link_distance = 1.2
    
    for i in 0..8 {
        let link = mesh::sphere {
            radius: 0.3
            position: vec3(0, 10.0 - i * link_distance, 0)
            material: materials::metal {
                albedo: color(0.4, 0.4, 0.5)
            }
            physics: {
                type: if i == 0 { static } else { dynamic }
                mass: 0.8
                collision_shape: sphere
            }
        }
        chain_links.push(link)
        
        // Connect to previous link with constraint
        if i > 0 {
            physics::point_constraint {
                object_a: chain_links[i-1]
                object_b: link
                anchor_a: vec3(0, -0.4, 0)     // Bottom of previous link
                anchor_b: vec3(0, 0.4, 0)      // Top of current link
                break_force: 50.0               // Constraint can break under stress
            }
        }
    }
    
    // Pendulum with realistic motion
    let pendulum_weight = mesh::sphere {
        radius: 0.8
        position: vec3(-5, 5, 0)
        material: materials::metal { albedo: color(0.8, 0.2, 0.2) }
        physics: {
            type: dynamic
            mass: 3.0
            collision_shape: sphere
        }
    }
    
    physics::distance_constraint {
        object_a: "world"                       // Anchor to world
        object_b: pendulum_weight
        anchor_a: vec3(-5, 8, 0)               // Fixed point in world
        anchor_b: vec3(0, 0, 0)                // Center of weight
        distance: 3.0                          // Rope length
        stiffness: 1.0                         // Rigid rope
    }
    
    // Give pendulum initial push
    pendulum_weight.physics.apply_impulse(vec3(8.0, 0, 0))
    
    // Spring-damper system
    let spring_base = mesh::cube {
        size: vec3(1, 1, 1)
        position: vec3(3, 0, 0)
        physics: { type: static }
    }
    
    let spring_weight = mesh::cube {
        size: vec3(0.8, 0.8, 0.8)
        position: vec3(3, 4, 0)
        material: color(0.8, 0.8, 0.2)
        physics: {
            type: dynamic
            mass: 1.5
            collision_shape: box
        }
    }
    
    physics::spring_constraint {
        object_a: spring_base
        object_b: spring_weight
        anchor_a: vec3(0, 1, 0)                // Top of base
        anchor_b: vec3(0, -0.5, 0)             // Bottom of weight
        rest_length: 2.0
        spring_constant: 50.0                  // Stiffness
        damping: 0.8                           // Energy loss
    }
}</pre>
        </div>

        <h2>5. Particle Systems</h2>
        <p>Create stunning visual effects with built-in particle systems:</p>

        <div class="code-block">
<pre>fn create_particle_effects() {
    // Fire effect
    particle_system fire_effect {
        position: vec3(0, 0, 0)
        
        // Emission properties
        emission_rate: 100.per_second
        burst_count: 0                      // Continuous emission
        lifetime: 2.0s
        
        // Spawn shape and distribution
        spawn_shape: sphere { radius: 0.3 }
        spawn_velocity: {
            direction: vec3(0, 1, 0)        // Upward
            speed: random_range(2.0, 4.0)
            spread_angle: 30.degrees        // Cone of emission
        }
        
        // Physics simulation
        gravity: vec3(0, -2.0, 0)          // Lighter gravity for fire
        drag: 0.5                          // Air resistance
        turbulence: {
            strength: 1.0
            frequency: 2.0                  // Flickering effect
        }
        
        // Visual properties over lifetime
        size: evolving {
            start: 0.1
            mid: 0.4 at 0.3                // Grows then shrinks
            end: 0.0
        }
        
        color: evolving {
            start: color(1.0, 1.0, 0.8, 1.0)     // Hot white
            mid: color(1.0, 0.5, 0.1, 0.8) at 0.5 // Orange flame
            end: color(0.3, 0.1, 0.1, 0.0)       // Dark ember
        }
        
        // Rendering
        material: materials::particle {
            texture: "flame.png"
            blend_mode: additive            // Glowing effect
            billboard: true                 // Always face camera
            soft_particles: true           // Smooth edges when intersecting
        }
    }
    
    // Smoke effect (follows fire)
    particle_system smoke_effect {
        position: vec3(0, 1, 0)            // Above fire
        
        emission_rate: 30.per_second
        lifetime: 5.0s
        
        spawn_shape: sphere { radius: 0.8 }
        spawn_velocity: {
            direction: vec3(0, 1, 0.2)      // Slightly forward
            speed: random_range(0.5, 1.5)
            spread_angle: 45.degrees
        }
        
        // Environmental forces
        gravity: vec3(0, 0.5, 0)           // Buoyant (rises)
        wind: vec3(0.5, 0, 0.3)           // Carries smoke away
        drag: 1.2
        
        size: evolving {
            start: 0.2
            end: 2.0                       // Expands as it rises
        }
        
        color: evolving {
            start: color(0.3, 0.3, 0.3, 0.6)     // Dark smoke
            end: color(0.7, 0.7, 0.7, 0.0)       // Fades to light
        }
        
        material: materials::particle {
            texture: "smoke.png"
            blend_mode: alpha
            billboard: true
        }
    }
    
    // Magical sparkles
    particle_system sparkle_effect {
        position: vec3(3, 2, 0)
        
        emission_rate: 50.per_second
        lifetime: 3.0s
        
        spawn_shape: sphere { radius: 1.5 }
        spawn_velocity: {
            speed: random_range(0.5, 2.0)
            direction: random_sphere_direction()
        }
        
        // No gravity - magical floating
        drag: 0.8
        
        size: evolving {
            start: 0.05
            mid: 0.15 at 0.2
            end: 0.02
        }
        
        color: evolving {
            start: color(1.0, 1.0, 1.0, 1.0)
            mid: color(0.8, 0.2, 1.0, 0.8) at 0.4    // Purple magic
            end: color(0.2, 0.8, 1.0, 0.0)           // Fade to cyan
        }
        
        // Twinkling effect
        brightness: sin(time * 10.0 + particle.id) * 0.5 + 1.0
        
        material: materials::particle {
            texture: "star.png"
            blend_mode: additive
            billboard: true
        }
    }
}</pre>
        </div>

        <h2>6. Advanced Scene Management</h2>
        <p>Handle complex scenes with multiple objects and optimization:</p>

        <div class="code-block">
<pre>fn create_complex_scene() {
    // Scene graph organization
    scene_node main_scene {
        // Environment group
        scene_node environment {
            transform: mat4::identity()
            
            // Terrain
            mesh::plane {
                size: vec2(100, 100)
                material: materials::terrain {
                    texture: "grass.jpg"
                    normal_map: "grass_normal.jpg"
                    texture_scale: vec2(10, 10)
                }
                physics: { type: static, collision_shape: plane }
            }
            
            // Skybox
            skybox {
                texture: "sky_panorama.hdr"
                rotation: quat::from_euler(0, time * 0.1, 0)  // Slowly rotating sky
                exposure: 1.2
            }
        }
        
        // Buildings group
        scene_node buildings {
            // Instanced objects for performance
            instanced_mesh building_instances {
                base_mesh: load_mesh("building.obj")
                material: materials::pbr {
                    albedo_texture: "building_diffuse.jpg"
                    normal_texture: "building_normal.jpg"
                    roughness_texture: "building_roughness.jpg"
                }
                
                // Generate building positions
                instances: generate_building_positions(100)
                
                // Level-of-detail (LOD) settings
                lod_levels: [
                    { distance: 0..20, mesh: "building_high.obj" },
                    { distance: 20..50, mesh: "building_medium.obj" },
                    { distance: 50..100, mesh: "building_low.obj" }
                ]
            }
        }
        
        // Dynamic objects group
        scene_node dynamic_objects {
            // Cars moving along paths
            for i in 0..20 {
                let car = mesh::load("car.obj") {
                    position: get_road_position(i)
                    material: materials::car_paint {
                        color: random_car_color()
                        metallic: 0.9
                        clearcoat: 0.8
                    }
                    physics: {
                        type: kinematic
                        collision_shape: "car_collision.obj"
                    }
                }
                
                // Animate along spline path
                animate_along_path(car, road_spline, speed: random_range(5.0, 15.0))
            }
        }
        
        // Effects group
        scene_node effects {
            // Weather system
            if weather_system.is_raining() {
                particle_system rain {
                    position: camera.position + vec3(0, 20, 0)
                    emission_rate: 1000.per_second
                    spawn_shape: box { size: vec3(40, 1, 40) }
                    
                    spawn_velocity: {
                        direction: vec3(0.1, -1, 0.1)  // Slightly angled
                        speed: 15.0
                    }
                    
                    lifetime: 2.0s
                    size: evolving { start: 0.02, end: 0.01 }
                    color: color(0.7, 0.7, 0.9, 0.6)
                }
            }
        }
    }
}</pre>
        </div>

        <h2>7. Performance Optimization</h2>

        <div class="advanced-box">
            <h3>⚡ High-Performance 3D Techniques</h3>
            <div class="code-block">
<pre>// Automatic performance optimization
@performance_critical
fn optimized_render_loop() {
    // Frustum culling - only render what's visible
    scene.enable_frustum_culling(camera.frustum)
    
    // Occlusion culling - don't render objects behind others
    scene.enable_occlusion_culling()
    
    // Level-of-detail (LOD) management
    scene.update_lod_system(camera.position) {
        lod_bias: 1.0                   // Higher = more detail
        max_triangles_per_frame: 100000 // Performance target
    }
    
    // Batch similar objects together
    scene.enable_instancing() {
        max_instances_per_batch: 1000
        instance_buffer_size: 4096
    }
    
    // Temporal upscaling for performance
    if context == "mobile" {
        render_scale: 0.75              // Render at 75% resolution
        temporal_upscaling: true        // AI upscaling
    }
    
    // Adaptive quality based on framerate
    @reactive
    fn adjust_quality_settings() {
        let current_fps = get_current_fps()
        
        if current_fps < 45 {
            // Reduce quality for better performance
            lighting.shadow_quality = medium
            post_processing.bloom.enabled = false
            scene.lod_bias = 0.7
        } else if current_fps > 70 {
            // Increase quality when performance allows
            lighting.shadow_quality = high
            post_processing.bloom.enabled = true
            scene.lod_bias = 1.2
        }
    }
}</pre>
            </div>
        </div>

        <h2>8. Interactive 3D Programming</h2>
        <p>Create responsive 3D experiences:</p>

        <div class="code-block">
<pre>fn create_interactive_experience() {
    // Object picking with mouse
    @user_input("mouse_click")
    fn handle_object_click(mouse_pos: vec2) {
        let ray = camera.screen_to_world_ray(mouse_pos)
        let hit_result = scene.raycast(ray)
        
        if hit_result.hit {
            let clicked_object = hit_result.object
            
            // Highlight the clicked object
            clicked_object.material.emissive -> color(1.0, 1.0, 0.0) over 200ms
            clicked_object.scale -> clicked_object.scale * 1.1 over 150ms
            
            // Reset after delay
            @delay(1s) {
                clicked_object.material.emissive -> color(0, 0, 0) over 500ms
                clicked_object.scale -> clicked_object.scale / 1.1 over 300ms
            }
            
            // Spawn particles at click location
            spawn_click_particles(hit_result.position)
        }
    }
    
    // Keyboard shortcuts for camera control
    @user_input("key_1") fn set_camera_view1() {
        camera.position -> vec3(10, 5, 10) over 1s
        camera.target -> vec3(0, 0, 0) over 1s
    }
    
    @user_input("key_2") fn set_camera_view2() {
        camera.position -> vec3(0, 15, 0) over 1s
        camera.target -> vec3(0, 0, 0) over 1s
    }
    
    // Gesture controls (for touch devices)
    @user_input("pinch_gesture")
    fn handle_pinch(scale_factor: float) {
        let zoom_target = camera.position * (1.0 / scale_factor)
        camera.position -> zoom_target over 200ms
    }
    
    // Voice commands (if available)
    @user_input("voice_command")
    fn handle_voice(command: string) {
        match command {
            "create cube" => {
                mesh::cube {
                    size: vec3(1, 1, 1)
                    position: camera.position + camera.forward * 3.0
                    material: color(random(), random(), random())
                }
            },
            "reset scene" => {
                scene.clear_dynamic_objects()
            }
        }
    }
}</pre>
        </div>

        <h2>9. Putting It All Together - Advanced Project</h2>
        <p>Build a complete interactive 3D scene with all the techniques:</p>

        <div class="code-block">
<pre>// Advanced 3D Scene: Magical Forest
import space3d with capabilities("render", "physics", "particles")
import procedural with capabilities("generate", "noise")

fn main() {
    world {
        camera {
            position: vec3(0, 3, 8)
            fov: 65.degrees
            enable_wasd_movement: true
            movement_speed: 3.0
        }
        
        lighting {
            // Dynamic time-of-day lighting
            light::directional sun {
                direction: get_sun_direction(time_of_day)
                color: get_sun_color(time_of_day)
                intensity: get_sun_intensity(time_of_day)
                cast_shadows: true
            }
            
            ambient: get_ambient_color(time_of_day)
            
            // Magical floating lights
            for i in 0..8 {
                light::point {
                    position: vec3(
                        sin(i * 45.degrees + time * 0.5) * 8,
                        2.0 + sin(time * 2.0 + i) * 0.8,
                        cos(i * 45.degrees + time * 0.5) * 8
                    )
                    color: hsv_to_rgb(i * 45.degrees, 0.8, 1.0)
                    intensity: 1.5 + sin(time * 3.0 + i) * 0.5
                    range: 5.0
                }
            }
        }
        
        physics {
            gravity: vec3(0, -9.81, 0)
        }
    }
    
    create_magical_forest()
    create_interactive_elements()
    
    render_world()
}

fn create_magical_forest() {
    // Procedural ground with shader
    mesh::plane {
        size: vec2(50, 50)
        resolution: (128, 128)
        position: vec3(0, 0, 0)
        
        vertex_shader: forest_ground_vertex
        material: forest_ground_material
        
        physics: { type: static, collision_shape: heightfield }
    }
    
    // Procedural trees
    for i in 0..30 {
        let tree_pos = random_forest_position()
        create_magical_tree(tree_pos)
    }
    
    // Floating crystals
    for i in 0..12 {
        create_floating_crystal(
            vec3(
                random_range(-20, 20),
                random_range(3, 8),
                random_range(-20, 20)
            )
        )
    }
}

shader forest_ground_vertex {
    vertex {
        let world_pos = vertex.position
        let height = fbm_noise(world_pos.xz * 0.1, octaves: 4) * 2.0
        vertex.position.y = height
        
        // Calculate normal for lighting
        let eps = 0.1
        let hL = fbm_noise((world_pos.xz + vec2(-eps, 0)) * 0.1, octaves: 4)
        let hR = fbm_noise((world_pos.xz + vec2(eps, 0)) * 0.1, octaves: 4)
        let hD = fbm_noise((world_pos.xz + vec2(0, -eps)) * 0.1, octaves: 4)
        let hU = fbm_noise((world_pos.xz + vec2(0, eps)) * 0.1, octaves: 4)
        
        vertex.normal = normalize(vec3(hL - hR, 2.0 * eps, hD - hU))
    }
}

material forest_ground_material: materials::pbr {
    albedo: color(0.2, 0.4, 0.1)
    normal_texture: "forest_floor_normal.jpg"
    roughness: 0.9
    
    // Animated moss glow
    emissive: color(0.1, 0.3, 0.1) * (sin(time * 0.5) * 0.3 + 0.3)
}</pre>
        </div>

        <div class="demo-viewport">
            <strong>🌲 The Result:</strong> A living, breathing magical forest with procedurally generated terrain, animated lighting, floating crystals, particle effects, and full interactivity. The entire scene responds to time of day, user input, and physics simulation.
        </div>

        <h2>10. Next Level Mastery</h2>
        <div class="magic-box">
            <p>You've mastered intermediate 3D programming! You can now:</p>
            <ul>
                <li>✨ Create photorealistic materials with PBR</li>
                <li>🎨 Write custom shaders for unique visual effects</li>
                <li>💡 Design complex lighting setups</li>
                <li>⚖️ Integrate realistic physics simulation</li>
                <li>✨ Build stunning particle effects</li>
                <li>⚡ Optimize performance for smooth 60fps</li>
                <li>🎮 Create interactive 3D experiences</li>
            </ul>
        </div>

        <h2>Advanced Challenge Projects</h2>
        <div class="two-column">
            <div class="feature-box">
                <h3>🏰 Project: Medieval Castle</h3>
                <ul>
                    <li>Procedural castle generation</li>
                    <li>Dynamic weather system</li>
                    <li>Day/night cycle with moon phases</li>
                    <li>Interactive torch lighting</li>
                    <li>Physics-based drawbridge</li>
                </ul>
            </div>
            
            <div class="magic-box">
                <h3>🌊 Project: Ocean Simulation</h3>
                <ul>
                    <li>FFT-based ocean waves</li>
                    <li>Underwater caustics effects</li>
                    <li>Dynamic foam generation</li>
                    <li>Floating object physics</li>
                    <li>Volumetric fog and lighting</li>
                </ul>
            </div>
        </div>

        <div class="navigation">
            <a href="tutorial_3d_beginner.html" class="nav-button">← 3D Beginner</a>
            <a href="tutorial_3d_advanced.html" class="nav-button">Advanced 3D →</a>
        </div>
    </div>
</body>
</html>